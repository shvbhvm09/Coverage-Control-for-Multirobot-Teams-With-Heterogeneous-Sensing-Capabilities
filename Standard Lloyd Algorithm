```matlab
% Coverage control using Lloyd's Algorithm.

% Shubham Daheriya
% 10/2024

%% Experiment Constants

% Run the simulation for a specific number of iterations
iterations = 2000;

%% Set up the Robotarium object

N = 7;
x_init = generate_initial_conditions(N, 'Width', 1.1, 'Height', 1.1, 'Spacing', 0.35);
x_init = x_init - [min(x_init(1,:)) - (-1.6 + 0.2); min(x_init(2,:)) - (-1 + 0.2); 0];
r = Robotarium('NumberOfRobots', N, 'ShowFigure', true, 'InitialConditions', x_init);

% Initialize velocity vector
dxi = zeros(2, N);

% Boundary
crs = [r.boundaries(1), r.boundaries(3);
       r.boundaries(1), r.boundaries(4);
       r.boundaries(2), r.boundaries(4);
       r.boundaries(2), r.boundaries(3)];

%% Grab tools we need to convert from single-integrator to unicycle dynamics

% Single-integrator -> unicycle dynamics mapping
[~, uni_to_si_states] = create_si_to_uni_mapping();
si_to_uni_dyn = create_si_to_uni_dynamics();
% Single-integrator barrier certificates
uni_barrier_cert_boundary = create_uni_barrier_certificate_with_boundary();
% Single-integrator position controller
motion_controller = create_si_position_controller('XVelocityGain', 0.8, 'YVelocityGain', 0.8, 'VelocityMagnitudeLimit', 0.1);

%% Plotting Setup
marker_size = determine_marker_size(r, 0.08);

x = r.get_poses();

verCellHandle = zeros(N, 1);
cellColors = cool(N);
for i = 1:N % color according to robot
    verCellHandle(i) = patch(x(1, i), x(2, i), cellColors(i, :), 'FaceAlpha', 0.3); % use color i  -- no robot assigned yet
    hold on
end
pathHandle = zeros(N, 1);
for i = 1:N % color according to
    pathHandle(i) = plot(x(1, i), x(2, i), '-.', 'color', cellColors(i, :) * .9, 'LineWidth', 4);
end
centroidHandle = plot(x(1, :), x(2, :), '+', 'MarkerSize', marker_size, 'LineWidth', 2, 'Color', 'k');

for i = 1:N % color according to
    xD = [get(pathHandle(i), 'XData'), x(1, i)];
    yD = [get(pathHandle(i), 'YData'), x(2, i)];
    set(pathHandle(i), 'XData', xD, 'YData', yD); % plot path position
end

r.step();
%% Main Loop

for t = 1:iterations
    % Retrieve the most recent poses from the Robotarium.  The time delay is
    % approximately 0.033 seconds
    x = r.get_poses();

    % Convert to SI states
    xi = uni_to_si_states(x);
    
    %% Algorithm
    [Px, Py] = lloydsAlgorithm(x(1, :)', x(2, :)', crs, verCellHandle);
    dxi = motion_controller(x(1:2, :), [Px'; Py']);
         
    %% Avoid actuator errors
    
    % To avoid errors, we need to threshold dxi
    norms = arrayfun(@(x) norm(dxi(:, x)), 1:N);
    threshold = 3/4 * r.max_linear_velocity;
    to_thresh = norms > threshold;
    dxi(:, to_thresh) = threshold * dxi(:, to_thresh) ./ norms(to_thresh);
    
    %% Use barrier certificate and convert to unicycle dynamics
    dxu = si_to_uni_dyn(dxi, x);
    dxu = uni_barrier_cert_boundary(dxu, x);
    
    %% Send velocities to agents
    
    % Set velocities
    r.set_velocities(1:N, dxu);
    
    %% Update Plot Handles
    for i = 1:N % color according to
        xD = [get(pathHandle(i), 'XData'), x(1, i)];
        yD = [get(pathHandle(i), 'YData'), x(2, i)];
        set(pathHandle(i), 'XData', xD, 'YData', yD); % plot path position
    end
    
    set(centroidHandle, 'XData', Px, 'YData', Py); % plot centroid position
     
    % Iterate experiment
    r.step();
end

% We can call this function to debug our experiment!  Fix all the errors
% before submitting to maximize the chance that your experiment runs
% successfully.
r.debug();

%% Helper Functions

% Marker Size Helper Function to scale size with figure window
% Input: robotarium instance, desired size of the marker in meters
function marker_size = determine_marker_size(robotarium_instance, marker_size_meters)

    % Get the size of the robotarium figure window in pixels
    curunits = get(robotarium_instance.figure_handle, 'Units');
    set(robotarium_instance.figure_handle, 'Units', 'Points');
    cursize = get(robotarium_instance.figure_handle, 'Position');
    set(robotarium_instance.figure_handle, 'Units', curunits);

    % Determine the ratio of the robot size to the x-axis (the axis are
    % normalized so you could do this with y and figure height as well).
    marker_ratio = (marker_size_meters) / (robotarium_instance.boundaries(2) -...
        robotarium_instance.boundaries(1));

    % Determine the marker size in points so it fits the window. cursize(3) is
    % the width of the figure window in pixels. (the axis are
    % normalized so you could do this with y and figure height as well).
    marker_size = cursize(3) * marker_ratio;

end

%% Lloyds algorithm put together by Aaron Becker

function [Px, Py] = lloydsAlgorithm(Px, Py, crs, verCellHandle)
    % LLOYDSALGORITHM runs Lloyd's algorithm on the particles at xy positions 
    % (Px,Py) within the boundary polygon crs for numIterations iterations
    % showPlot = true will display the results graphically.  
    % 
    % Lloyd's algorithm starts with an initial distribution of samples or
    % points and consists of repeatedly executing one relaxation step:
    %   1.  The Voronoi diagram of all the points is computed.
    %   2.  Each cell of the Voronoi diagram is integrated and the centroid is computed.
    %   3.  Each point is then moved to the centroid of its Voronoi cell.
    % 
    % Inspired by http://www.mathworks.com/matlabcentral/fileexchange/34428-voronoilimit
    % Requires the Polybool function of the mapping toolbox to run.
    % 
    % Run with no input to see example.  To initialize a square with 50 robots 
    % in left middle, run:
    % lloydsAlgorithm(0.01 * rand(50, 1), zeros(50, 1) + 1/2, [0, 0; 0, 1; 1, 1; 1, 0], 200, true)
    % 
    % Made by: Aaron Becker, atbecker@uh.edu
    format compact

    % initialize random generator in repeatable fashion
    sd = 20;
    rng(sd)

    xrange = max(crs(:, 1)) - min(crs(:, 1));
    yrange = max(crs(:, 2)) - min(crs(:, 2));

    % Apply LLYOD's Algorithm
    [v, c] = VoronoiBounded(Px, Py, crs);

    for i = 1:numel(c) % calculate the centroid of each cell
        [cx, cy] = PolyCentroid(v(c{i}, 1), v(c{i}, 2));
        cx = min(max(crs(:, 1)), max(min(crs(:, 1)), cx));
        cy = min(max(crs(:, 2)), max(min(crs(:, 2)), cy));
        if ~isnan(cx) && inpolygon(cx, cy, crs(:, 1), crs(:, 2))
            Px(i) = cx;  % don't update if goal is outside the polygon
            Py(i) = cy;
        end
    end

    for i = 1:numel(c) % update Voronoi cells
        set(verCellHandle(i), 'XData', v(c{i}, 1), 'YData', v(c{i}, 2));
    end
end

function [Cx, Cy] = PolyCentroid(X, Y)
    % POLYCENTROID returns the coordinates for the centroid of polygon with vertices X,Y
    % The centroid of a non-self-intersecting closed polygon defined by (x,y) is
    % given by the formulas: 
    %
    % Cx = (1/A) * integral(x*dy) 
    % Cy = (1/A) * integral(y*dx) 
    %
    % where A is the area of the polygon.  If the polygon is self-intersecting,
    % this returns the centroid of the external shape (that is, the value of the
    % areas can be negative)
    X = [X; X(1)]; % close the polygon
    Y = [Y; Y(1)]; % close the polygon
    A = sum(X(1:end-1) .* Y(2:end)) - sum(Y(1:end-1) .* X(2:end));
    Cx = sum((X(1:end-1) + X(2:end)) .* (X(1:end-1) .* Y(2:end) - Y(1:end-1) .* X(2:end))) / (3*A);
    Cy = sum((Y(1:end-1) + Y(2:end)) .* (X(1:end-1) .* Y(2:end) - Y(1:end-1) .* X(2:end))) / (3*A);
end
```
